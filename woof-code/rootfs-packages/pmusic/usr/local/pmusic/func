#!/bin/bash
#pMusic
#GPL - Copyright Sigmund Berglund

IFS=$'\n'
export TEXTDOMAIN=pmusic


case "$1" in
-check_playlist)
	FILE="$2"
	case "$FILE" in *pmu) TMP=4;; *pmd) TMP=1;; esac #set field to read
	#first check if there an update is require
	while read I; do if [ "$(grep "^/" <<< "$I")" ] && [ ! -f "$I" ]; then C=1 ; fi; done <<< "$(cut -d'|' -f$TMP "$FILE")"
	if [ "$C" != "1" ] || [ "`grep -F 'pmusic_playlistcheck' <<< $(ps -eo pid,command)`" ]; then exit; fi


	export pmusic_playlistcheck='
<window title="pMusic" icon-name="pmusic">
 <vbox>
  <frame '$(gettext 'Quirky playlist')'>
   <pixmap icon_size="6"><input file stock="gtk-dialog-question"></input></pixmap>
   <text use-markup="true" can-focus="false"><label>"<b>'$(gettext 'Album/Favorites list are out of shape. - Audio file(s) have been (re)moved.')'</b>"</label></text>
   <text can-focus="false"><label>"'$(gettext "This is not critical as pMusic will search for an alternative source, and play this. But for speed and db-info, it is recommended to keep stuff updated.

To avoid this message to bother you more, don't close this window.")'"</label></text>
  </frame>
  <hbox space-expand="true" space-fill="true">
   <button space-expand="false" space-fill="false">
    <input file stock="gtk-cancel"></input>
    <label>'$(gettext 'Cancel')'</label>
   </button>
   <text space-expand="true" space-fill="true"><label>""</label></text>
   <button has-focus="true" space-expand="false" space-fill="false">
    <input file stock="gtk-audio_playlist_setup"></input>
    <label>'$(gettext 'Fix this list')'</label>
    <action type="exit">quickfix</action>
   </button>
   <button space-expand="false" space-fill="false">
    <input file stock="gtk-refresh"></input>
    <label>'$(gettext 'Check and fix all lists')'</label>
    <action type="exit">global</action>
   </button>
  </hbox>
 </vbox>
</window>'
I=$IFS; IFS=""
for STATEMENTS in  $($GTKDIALOG -p pmusic_playlistcheck --center); do
	eval $STATEMENTS
done
IFS=$I

	case $EXIT in
		global)
			$APPDIR/func_index -update_index update_playlists
			;;
		quickfix)
			echo "$(gettext 'Fix playlist')" > $WORKDIR/splashtext
			$APPDIR/box_splash &
			if [ "$(grep -F '.pmu' <<< "$FILE")" ]; then
				$APPDIR/func_index -update_pmu "$FILE"
			else
				$APPDIR/func_index -update_pmd "$FILE"
			fi
			echo 100 > $WORKDIR/splash
			;;
	esac
	;;
	
-playlist_collapse)
	FILE="$2"
	ICON="`grep "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f15`" #could be favorite list
	ALBUM="`grep "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f4`" #pmusic generated album list
	MY_DATE="`grep "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f6`" #browsing provides date - handy for radiohots grabber
	SOURCELIST_PRE="`grep -B 1000 -F "pmusicbrowse_collapse:$FILE" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_collapse:$FILE"`"
	SOURCELIST_POST="`grep -A 1000 -F "pmusicbrowse_collapse:$FILE" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_collapse:$FILE"`"
	echo "$SOURCELIST_PRE" > $WORKDIR/sourcelist
	if [ "$ALBUM" ]; then #pmusic generated album list
		ARTIST="`basename "$FILE" | awk -F ' - ' '{print $1}'`"
		echo "pmusicbrowse_expand:$2|$ARTIST||$ALBUM||$MY_DATE||||||||$2|$ICON||||||" >> $WORKDIR/sourcelist
	else
		find "$FILE" -printf "pmusicbrowse_expand:%p|%f||||$MY_DATE||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
	fi
	#remove track-lines
	TMP=`echo "$SOURCELIST_POST" | grep -m1 -n '___________________________' | tail -n1 | cut -d: -f1`
	echo "$SOURCELIST_POST" | tac | head -n -$TMP | tac >> $WORKDIR/sourcelist
	;;
-playlist_expand)
	FILE="$2"
	ICON="`grep -Fm1 "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f15`" #could be favorite list
	ALBUM="`grep -Fm1 "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f4`" #pmusic generated album list
	MY_DATE="`grep -Fm1 "${FILE}|" $WORKDIR/sourcelist | cut -d'|' -f6`" #browsing provides date - handy for radiohots grabber
	SOURCELIST_PRE="`grep -B 1000 -F "pmusicbrowse_expand:$FILE" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_expand:$FILE"`"
	SOURCELIST_POST="`grep -A 1000 -F "pmusicbrowse_expand:$FILE" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_expand:$FILE"`"
	echo "$SOURCELIST_PRE" > $WORKDIR/sourcelist
	case $FILE in
		*.pmd)
			$APPDIR/func -check_playlist "$FILE" & #check if paths is valid
			find "$FILE" -printf "pmusicbrowse_collapse:%p|%f||||$MY_DATE||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			echo -n > $WORKDIR/tmp_playlist_expand
			while read I; do
				FILE2="`cut -d'|' -f1 <<< "$I"`"
				[ ! "$FILE2" ] && FILE2="`cut -d'|' -f2 <<< "$I"`" #in case no valid file (ie. after an update of favorite lists in the update_index function.) 
				[ "`grep -F 'jamendo.com' <<< "$I"`" ] && URL_JAMENDO="`echo "$I" | awk -F 'id=' '{print $2}' | awk -F '|' '{print $1}'`"
				if [ "`grep -Fm1 "$FILE2" "$STORAGE_DIR/index_mymusic"`" ]; then
					grep -Fm1 "$FILE2" "$STORAGE_DIR/index_mymusic" >> $WORKDIR/tmp_playlist_expand
				elif [ "$URL_JAMENDO" ] && [ "`grep -Fm1 "$URL_JAMENDO" "$STORAGE_DIR/index_webmusic_jamendo"`" ]; then
					grep -Fm1 "$URL_JAMENDO" "$STORAGE_DIR/index_webmusic_jamendo" >> $WORKDIR/tmp_playlist_expand
				else
					grep -Fm1 "$FILE2" "$FILE" >> $WORKDIR/tmp_playlist_expand
				fi
			done < "$FILE"
			$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_playlist_expand 0 0 "    " >> $WORKDIR/sourcelist #get rating
			;;
		*.pmu)
			$APPDIR/func -check_playlist "$FILE" & #check if paths is valid
			if [ "$ALBUM" ]; then #pmusic generated album list
				ARTIST="`basename "$FILE" | awk -F ' - ' '{print $1}'`"
				echo "pmusicbrowse_collapse:$2|$ARTIST||$ALBUM||||$MY_DATE||||||$2|$ICON||||||" >> $WORKDIR/sourcelist
			else
				find "$FILE" -printf "pmusicbrowse_collapse:%p|%f||||$MY_DATE||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			fi
			echo -n > $WORKDIR/tmp_playlist_expand
			while read I; do
				FILE2="`cut -d'|' -f4 <<< "$I"`"
				if [ "$FILE2" ]; then
					#local file - we sync with info in database
					if [ "`grep -Fm1 "$FILE2" "$STORAGE_DIR/index_mymusic"`" ]; then
						grep -Fm1 "$FILE2" "$STORAGE_DIR/index_mymusic" >> $WORKDIR/tmp_playlist_expand
					#jamendo
					elif [ "`grep -F 'jamendo.com' <<< "$FILE2"`" ]; then
						ARTIST="`cut -d'|' -f3 <<< "$I" | awk -F' - ' '{print $1}'`"
						TITLE="`cut -d'|' -f3 <<< "$I" | awk -F' - ' '{print $2}'`"
						LENGTH="`cut -d'|' -f2 <<< "$I"`"
						echo "$FILE2|$ARTIST|$TITLE|||||||mp3|96|$LENGTH||$FILE2|gtk-audio" | tr -d '\r' >> $WORKDIR/tmp_playlist_expand
					#if item in pmu-file is not in db nor URL
					else
						echo "$FILE2|$(basename "$FILE2")||||||||||||$FILE2|gtk-audio" | tr -d '\r' >> $WORKDIR/tmp_playlist_expand
					fi
				else
					echo "$I" | awk -F'|' '{print "|" $3 "|||||||||||||gtk-audio_missing"}' >> $WORKDIR/tmp_playlist_expand
				fi
			done < "$FILE"
			$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_playlist_expand 0 0 "    " >> $WORKDIR/sourcelist #get rating
			;;
		*.m3u)
			find "$FILE" -printf "pmusicbrowse_collapse:%p|%f||||$MY_DATE||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			while read I; do
				[ "`echo "$I" | grep -E '#EXTM3U|#M3U'`" ] && continue #header info. We don't use this
				if [ "`echo "$I" | grep '#EXT'`" ]; then
					#we use #EXT info in m3u if available
					LENGTH="`echo "$I" | cut -d: -f2- | cut -d, -f1`"
					if [ "$LENGTH" -gt 0 ]; then
						LENGTH=`$APPDIR/func -sec2time $LENGTH` #m3u stores length in seconds, we want a human readable length
					else
						LENGTH=""
					fi
					NAME="`echo "$I" | cut -d, -f2-`"
					continue #if EXT line, go to next line...
				fi
				[ ! "$NAME" ] && NAME="`basename "$I"`"
				#Adress (path/URL)
				case $I in
					cdda:*) #CD-audio
						ADR="$I"
						;;
					*://*) #streaming
						ADR="$I"
						;;
					*/*) #path is defined in playlist
						if [ -s "$I" ]; then #path exist, use path in playlist
							ADR="$I"
						else #Use current dir
							TMP="`dirname "$FILE"`"
							TMP2="`basename "$I"`"
							ADR="$TMP/$TMP2"
						fi
						;;
					*) #no path for files in list. Use current dir
						TMP="`dirname "$FILE"`"
						ADR="$TMP/$I"
						;;
				esac
				echo "$ADR|    $NAME||||||||||$LENGTH||$ADR|" | tr -d '\r' >> $WORKDIR/sourcelist
				NAME=""
			done < "$FILE"
			;;
		*.pls)
			find "$FILE" -printf "pmusicbrowse_collapse:%p|%f||||$MY_DATE||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			while read I; do
				NR="`cut -d= -f1 <<< "$I" | cut -d'e' -f2`"
				ADR="`cut -d= -f2 <<< "$I"`"
				#length
				TMP="`grep -F "Length${NR}=" "$SOURCE" | cut -d= -f2`"
				if [ "$TMP" -gt 0 ]; then
					LENGTH=`$APPDIR/func -sec2time $TMP` #pls stores length in seconds, we want a human readable length
				else
					LENGTH=""
				fi
				#---
				NAME="`grep -F "Title${NR}=" "$SOURCE" | cut -d= -f2`"
				[ ! "$NAME" ] && NAME="`basename "$ADR"`"
				echo "$ADR|    $NAME||||||||||$LENGTH||$ADR|" | tr -d '\r' >> $WORKDIR/sourcelist
			done <<< "$(grep "^File" "$FILE")"
			;;
	esac
	echo 'pmusic_expand_end|___________________________' >> $WORKDIR/sourcelist
	echo "$SOURCELIST_POST" >> $WORKDIR/sourcelist
	;;
-browse)
	case $SOURCE in 
		pmusicbrowse_expand:*)
			SOURCE="`echo "$SOURCE" | cut -d: -f2-`"
			[ "`grep -iE "\.pmu\$|\.m3u\$|\.pls\$" <<< "$SOURCE"`" ] && . $APPDIR/func_add -check_source #is it where db points?
			$APPDIR/func -playlist_expand "$SOURCE"
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_collapse:*)
			TMP="`echo "$SOURCE" | cut -d: -f2-`"
			$APPDIR/func -playlist_collapse "$TMP"
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_parent:*)
			PARENT="`echo "$SOURCE" | cut -d: -f2`"
			SOURCE="`echo "$SOURCE" | cut -d: -f3-`"
			;;
		pmusicbrowse_favorites)
			$APPDIR/func_favorites -show_favorites
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_radio:*)
			TMP="`cut -d: -f2- <<< "$SOURCE"`"
			grep "|$TMP" "$STORAGE_DIR/index_radio" | cut -d'|' -f1-2 > $WORKDIR/tmp_radio
			awk -F'\n' '{print $1 "|||||||||||||gtk-audio_url"}' $WORKDIR/tmp_radio > $WORKDIR/sourcelist #give it an icon in sourcelist
			$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio stations')" & #update history
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
	esac
	#---
	[ "$PTR_BTN" = "3" ] && exit #right-click menu
	if [ -d "${SOURCE}" ]; then
		#define parent directory.
		if [ "$PARENT" ]; then
			echo "$PARENT|..|||||||||||||gtk-go-back" > $WORKDIR/sourcelist
		else
			TMP="`dirname "$SOURCE"`"
			[ "$SOURCE" = ".." ] && SOURCE="$TMP"
			if [ "$SOURCE" != "/" ]; then echo "$TMP|..|||||||||||||gtk-go-up" > $WORKDIR/sourcelist; else echo -n > $WORKDIR/sourcelist; fi
		fi
		#---
		echo "$SOURCE" > $WORKDIR/filebrowser_dir #remember path for next time
		AUDIO_FORMATS2="`echo "$AUDIO_FORMATS" | sed 's/\\$/\\\|/g'`" #example: |/path/file.mp3|
		find -L "$SOURCE" -mindepth 1 -maxdepth 1 -printf "%f_test%p|%f||||%TY %Tm/%Td %TH:%TM||||||||%p|gtk-%Y%f\n" \
		| sort -t'|' -k15,15 \
		| sed \
		-e 's/gtk-d.*$/gtk-directory/g' \
		-e 's/gtk-f.*\.pmd$/gtk-audio_playlist_favorites/g' \
		-e 's/gtk-f.*\.m3u$/gtk-audio_playlist/g' \
		-e 's/gtk-f.*[.pmu|.pls|.asx]$/gtk-audio_playlist/g' \
		-e 's/gtk-f.*$/gtk-audio/g' \
		-e "s/^.*\.pmu_test/pmusicbrowse_expand:/g" \
		-e "s/^.*\.pmd_test/pmusicbrowse_expand:/g" \
		-e "s/^.*\.m3u_test/pmusicbrowse_expand:/g" \
		-e "s/^.*\.pls_test/pmusicbrowse_expand:/g" \
		-e "s/^.*_test//g" \
		| grep -iE "$AUDIO_FORMATS2|\.pmu\||\.pmd\||\.m3u\||\.pls\||\.asx\||gtk-directory" \
		| grep -vF '/.' \
		>> $WORKDIR/sourcelist
		#---
		[ -f $WORKDIR/gui_is_running ] && echo true > $WORKDIR/UPDATE_SOURCELIST2
		[ ! "`echo "$*" | grep -F 'history'`" ] && $APPDIR/func -add_to_history "$SOURCE" & #update history
	fi
	;;
-set_gtk)
	#GTK-theme
	[ -f $APPDIR/themes/$THEME/gtkrc_mainwindow ] && TMP=":$APPDIR/themes/$THEME/gtkrc_mainwindow"
	#include gtk code for svg-headings
	echo 'pixmap_path "'$WORKDIR'"
		style "svgHeadingImg" { bg_pixmap[NORMAL] = "heading.svg" }
		widget "*svgheading" style "svgHeadingImg"
		style "svgSplashImg" { bg_pixmap[NORMAL] = "splash.svg" }
		widget "*svgsplash" style "svgSplashImg"' > $WORKDIR/svg_gtkrc
	if [ "`grep -F 'ONLY_THIS_GTKTHEME=true' $APPDIR/themes/$THEME/themerc 2> $STDERR`" ]; then
		export GTK2_RC_FILES="$TMP:$WORKDIR/svg_gtkrc:$APPDIR/themes/$THEME/gtkrc"
	else
		export GTK2_RC_FILES="$HOME/.gtkrc-2.0:$TMP:$WORKDIR/svg_gtkrc:$APPDIR/themes/$THEME/gtkrc"
	fi
	;;
-reset_gtk) #the pMusic specific gtk-theme is not meant for all kinds of dialogs...
	if [ -f "$APPDIR/themes/$THEME/gtkrc" ]; then
		if [ "`grep -F 'THEME_ALL_DIALOGS=false' $APPDIR/themes/$THEME/themerc 2> $STDERR`" ]; then 
			export GTK2_RC_FILES="`grep -m 1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2> $STDERR`:$WORKDIR/svg_gtkrc" #get active theme
		else
			. $APPDIR/func -set_gtk
		fi
	fi
	;;
-plugins)
	find $APPDIR/plugins/ | grep -vE "rc$|/$" > $WORKDIR/tmp
	while read I; do
		. "${I}.rc" #read plugin info from rc file
		XML_PLUGINS=$XML_PLUGINS'
		<vbox>
		<hbox>
		 <pixmap width-request="90" height-request="90" space-expand="false" space-fill="false"><input file>'$PLUGIN_IMAGE'</input><height>80</height></pixmap>
		 <vbox>
		  <text height-request="5"><label>""</label></text>
		  <hbox>
		   <text space-expand="false" space-fill="false" use-markup="true"><label>"<b>'$PLUGIN_NAME'</b>"</label></text>
		   <text space-expand="true" space-fill="true"><label>""</label></text>
		  </hbox>
		  <hbox>
		   <text space-expand="false" space-fill="false"><label>'$PLUGIN_DESCRIPTION'</label></text>
		   <text space-expand="true" space-fill="true"><label>""</label></text>
		  </hbox>
		 </vbox>
		 <text space-expand="true" space-fill="true"><label>""</label></text>
		 <vbox>
		  <button>
		   <label>'$(gettext 'Uninstall')'</label>
		   <input file stock="gtk-clear"></input>
		   <action>rm '$I'; rm '$I'.rc</action>
		   <action>disable:'$PLUGIN_EXEC'</action>
		  </button>'
		   if [ $PLUGIN_RUN_AT_START = true ]; then
		    XML_PLUGINS=$XML_PLUGINS'
		    <text use-markup="true"><label>"<i>'$(gettext 'Runs at startup')'</i>"</label></text>'
		   else
		    XML_PLUGINS=$XML_PLUGINS'
		    <button>
		     <label>'$(gettext 'Run now')'</label>
		     <input file stock="gtk-execute"></input>
		     <action>exec '$APPDIR'/plugins/'$PLUGIN_EXEC' &</action>
		    </button>'
		   fi
		  XML_PLUGINS=$XML_PLUGINS'
		 </vbox>
		 <variable>'$PLUGIN_EXEC'</variable>
		</hbox>
		<hseparator></hseparator>
		</vbox>'
	done < $WORKDIR/tmp

	echo '
<window title="pMusic - '$(gettext 'Plugins')'" icon-name="pmusic" default_width="470" default_height="400">
<vbox>
 '"$($APPDIR/func_svg -heading "$(gettext 'Plugins')")"'
 <vbox scrollable="true" spacing="0" width="600">
   '$XML_PLUGINS'
 </vbox>
 <hbox>
  <button>
   <label>'$(gettext 'Check new Plugins')'</label>
   <input file stock="gtk-go-down"></input>
   <action>EXIT:install</action>
  </button>
  <button ok></button>
 </hbox>
</vbox>
</window>' > $WORKDIR/xml_pmusic_plugins
	[ $TOOLTIPS = false ] && sed -i 's%tooltip-text%tooltipXXXtext%g' $WORKDIR/xml_pmusic_plugins #deactivate tooltips
	I=$IFS; IFS=""
	for STATEMENTS in $($GTKDIALOG -f $WORKDIR/xml_pmusic_plugins); do
		eval $STATEMENTS
	done
	IFS=$I
	case $EXIT in
		install)
			export GTK2_RC_FILES="`grep -m 1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2> $STDERR`" #use global gtk-theme for browser
			$BROWSER "$PLUGIN_URL" &
			;;
	esac
	;;
-add_to_history)
	if [ ! "`tail -n 1 "$STORAGE_DIR/index_history" | grep "|    $2$"`" ]; then
		TMP=`date +%s`
		echo "$TMP|pmusic_history:$TMP|    $2" >> "$STORAGE_DIR/index_history"
		cp $WORKDIR/sourcelist "$STORAGE_DIR"/history_files/$TMP
		cp $WORKDIR/tmp_search_albumart "$STORAGE_DIR"/history_files/${TMP}_albumart 2> $STDERR
		rm -f $WORKDIR/history #reset undo/redo function
		#keep 100 history items 
		ls -1 "$STORAGE_DIR"/history_files > $WORKDIR/tmp
		if [ `cat $WORKDIR/tmp | wc -l` -gt 100 ]; then
			TMP=`head -n 1 $WORKDIR/tmp`
			rm -f "$STORAGE_DIR"/history_files/$TMP
			tail -n 100 "$STORAGE_DIR/index_history" > $WORKDIR/tmp
			mv -f $WORKDIR/tmp "$STORAGE_DIR/index_history"
		fi
	fi
	;;
-history_undo)
	[ "`head -n 1 "$STORAGE_DIR/index_history" | cut -d'|' -f1`" = "$(<$WORKDIR/history)" ] && exit
	if [ ! -s $WORKDIR/history ]; then #first undo-click
		HISTORY_NR="`tail -n 1 "$STORAGE_DIR/index_history" | cut -d'|' -f1`" #last active search/browse
	else
		HISTORY_NR="$(<$WORKDIR/history)"
	fi
	SEARCH="`grep -FB 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f3 | head -n 1 | cut -c 5-`"
	grep -FB 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | head -n 1 > $WORKDIR/history
	echo "$SEARCH" > $WORKDIR/filebrowser_dir
	TMP="`grep -FB 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | head -n 1`" 
	cp -f "$STORAGE_DIR"/history_files/$TMP $WORKDIR/sourcelist 
	#update albumart
	cp -f "$STORAGE_DIR"/history_files/${TMP}_albumart $WORKDIR/tmp_search_albumart
	$APPDIR/func -search_albumart_update
	;;
-history_redo)
	[ ! -s $WORKDIR/history ] && exit
	[ "`tail -n 1 "$STORAGE_DIR/index_history" | cut -d'|' -f1`" = "$(<$WORKDIR/history)" ] && exit
	HISTORY_NR="$(<$WORKDIR/history)"
	SEARCH="`grep -FA 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f3 | tail -n 1 | cut -c 5-`" 
	grep -FA 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | tail -n 1 > $WORKDIR/history
	echo "$SEARCH" > $WORKDIR/filebrowser_dir
	TMP="`grep -FA 1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | tail -n 1`" 
	cp -f "$STORAGE_DIR"/history_files/$TMP $WORKDIR/sourcelist 
	#update albumart
	cp -f "$STORAGE_DIR"/history_files/${TMP}_albumart $WORKDIR/tmp_search_albumart
	$APPDIR/func -search_albumart_update
	;;
-dependency_check)
	if type rxvt > /dev/null 2>&1 && [ "`grep -Fi puppy /etc/DISTRO_SPECS`" ]; then
		rxvt --hold +sb -bg black -fg grey -cr black -geometry 57x20 -title "pMusic - $(gettext 'Dependecy check')" -e pmusic -D &
	else
		xterm --hold -e pmusic -D &
	fi
	;;
-sec2time) #transform 100 sec to 01:40
	MIN=$(($2/60))
	SEC=$(($2-($MIN*60)))
	echo $(printf "%02d" $MIN):$(printf "%02d" $SEC)
	;;
-faq)
	export GTK2_RC_FILES="`grep -m 1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2> $STDERR`" #use global gtk-theme for browser
	[ $MY_LANGUAGE = auto ] && NLS=$LANG || NLS=$LANGUAGE #$NLS is temporary, and only used here
	if [ -s /usr/share/doc/help/${NLS%.*}/pmusic_faq.html ]; then
		$BROWSER /usr/share/doc/help/${NLS%.*}/pmusic_faq.html &
	elif [ -s /usr/share/doc/help/${NLS%_*}/pmusic_faq.html ]; then #fallback to macrolanguage if available (ISO 639-1 two letter code: en, es, fr, etc.)
		$BROWSER /usr/share/doc/help/${NLS%_*}/pmusic_faq.html &
	else
		echo "$(gettext 'No FAQ available on local system.
Downloading from internet.')" > $WORKDIR/splashtext
		$APPDIR/box_splash &
		#check internet connection
		LANG=C wget --spider "$FTP_SERVER/pmusic_faq_en.html" 2> $WORKDIR/tmp
		if [ "`grep -Ei "unable to resolve host|file does not exist" $WORKDIR/tmp`" ]; then
			#let's try the alternative ftp server
			LANG=C wget --spider "$FTP_SERVER_2/pmusic_faq_en.html" 2> $WORKDIR/tmp
			if [ "`grep -Ei "unable to resolve host|file does not exist" $WORKDIR/tmp`" ]; then
				sleep 0.2
				echo 100 > $WORKDIR/splash #reset progress bar
				TXT1="<b>$(gettext 'No connection to server')</b>"
				. $APPDIR/box_ok
				exit
			else
				MY_SERVER="$FTP_SERVER_2"
				MY_USER="$FTP_USER_2"
				MY_PASSWORD="$FTP_PASSWORD_2"
			fi
		else
			MY_SERVER="$FTP_SERVER"
			MY_USER="$FTP_USER"
			MY_PASSWORD="$FTP_PASSWORD"
		fi
		#---
		[ ! -d /usr/share/doc/help/${NLS%_*} ] && mkdir /usr/share/doc/help/${NLS%_*}
		wget --tries=1 -T 3 --user $MY_USER --password $MY_PASSWORD --output-document=/usr/share/doc/help/${NLS%_*}/pmusic_faq.html $MY_SERVER/pmusic_faq_${NLS%_*}.html
		#use english as fallback if local faq does not exist
		if [ ! -s /usr/share/doc/help/${NLS%_*}/pmusic_faq.html ]; then
			NLS=en
			[ ! -d /usr/share/doc/help/en ] && mkdir /usr/share/doc/help/en
			if [ ! -s /usr/share/doc/help/en/pmusic_faq.html ]; then
				wget --tries=1 -T 3 --user $MY_USER --password $MY_PASSWORD --output-document=/usr/share/doc/help/en/pmusic_faq.html $MY_SERVER/pmusic_faq_en.html
			fi
		fi
		echo 100 > $WORKDIR/splash
		$BROWSER /usr/share/doc/help/${NLS%_*}/pmusic_faq.html
	fi
	;;
-statusbar_playlist)
	#calculate length by sum up columns
	MIN=`cut -d'|' -f2 $WORKDIR/playlist | awk -F: '{ SUM += $1} END { print SUM*60 }'`
	SEC=`cut -d'|' -f2 $WORKDIR/playlist | awk -F: '{ SUM += $2} END { print SUM }'`
	if [ ! "$SEC" ]; then #if list is empty
		SEC_TOTAL=00; MIN_TOTAL=0
	else
		MIN_TOTAL=$((($MIN+$SEC)/60))
		SEC_TOTAL=$((($MIN+$SEC)-($MIN_TOTAL*60)))
		[ ${#SEC_TOTAL} -eq 1 ] && SEC_TOTAL="0$SEC_TOTAL" #ensure 2 digits
	fi
	#---
	. $CONFIG #missing array values that won't export
	echo " (${MIN_TOTAL}:${SEC_TOTAL})" > $WORKDIR/statusbar_playlist
	;;

-radio)
	#check if db exists
	if [  ! -s "$STORAGE_DIR/index_radio" ]; then
		echo -e "pmusic_radio|$(gettext 'Missing index')|||||||||||||gtk-info\npmusic_radio|$(gettext 'Doubleclick here to setup')" > $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
		exit
	fi
	#---
 	if [ "$2" = "-genre" ]; then
		cat $APPDIR/radio-tags | sed 's%$%|||||||||||||gtk-pmusic%g' > $WORKDIR/sourcelist
		$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio Genre')" & #update history
	elif [ "$2" = "-country" ]; then
		cat $APPDIR/radio-country | sed 's%$%|||||||||||||gtk-country%g' > $WORKDIR/sourcelist
		$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio Country')" & #update history
	fi
 	echo true > $WORKDIR/UPDATE_SOURCELIST #update source-list
	;;
	
-playlist_move)
	#button right-click --> already run -playlist_menu
	if [ "$(<"$WORKDIR/RIGHT_MENU")" = "true" ]; then echo -n > $WORKDIR/RIGHT_MENU; exit; fi
	#exit if no valid item
	[ "`cat $WORKDIR/PLAYLIST_PRESS_EVENT | wc -l`" -gt 1 ] && exit
	#button mid-click
	if [ $BUTTON = 2 ]; then
		$APPDIR/func -remove_from_list
		exit
	fi
	#Button left-click
	PLAYLIST_PRESS_EVENT=($(<"$WORKDIR/PLAYLIST_PRESS_EVENT"))
	PRESS_EVENT="`grep -F "$PLAYLIST_PRESS_EVENT" $WORKDIR/playlist`"
	RELEASE_EVENT="`grep -F "$PLAYLIST" $WORKDIR/playlist`"
	#move song in playlist
	if [ "$RELEASE_EVENT" != "$PRESS_EVENT" ]; then
		( flock -e 201
			grep -Fv "$PRESS_EVENT" $WORKDIR/playlist > $WORKDIR/tmp
			if [ `echo "$RELEASE_EVENT" | grep -c ^` -gt 1 ]; then #move last. RELEASE_EVENT includes all songs if nothing is choosen
				mv -f $WORKDIR/tmp $WORKDIR/tmp1
				echo "$PRESS_EVENT" >> $WORKDIR/tmp1
			else #normal move
				grep -Fm1 -B1000 "$RELEASE_EVENT" $WORKDIR/tmp | grep -vF "$RELEASE_EVENT" > $WORKDIR/tmp1
				echo "$PRESS_EVENT" >> $WORKDIR/tmp1
				grep -Fm1 -A1000 "$RELEASE_EVENT" $WORKDIR/tmp >> $WORKDIR/tmp1
			fi
			mv -f $WORKDIR/tmp1 $WORKDIR/playlist
		) 201>$WORKDIR/playlist.lockfile 
	else #play
		if [ "$PLAYLIST_PRESS_EVENT" ]; then
			#avoid rating for playing track
			ps -eo pid,s,command > $WORKDIR/tmp
			if [ "`grep aplay $WORKDIR/tmp`" ]; then #playing
				echo true > $WORKDIR/NO_RATING
			fi
			#---
			echo 0 > $WORKDIR/SS
			$APPDIR/func_player -stop -skip_update
			cut -d'|' -f5 <<< "$RELEASE_EVENT" > $WORKDIR/PLAYLIST
			$APPDIR/func_player -playing &
			exit 0
		fi
	fi
	;;
-playlist_play)
	echo 0 > $WORKDIR/SS
	$APPDIR/func_player -stop -skip_update
	grep -Fm1 "$PLAYLIST" $WORKDIR/playlist | cut -d'|' -f5  > $WORKDIR/PLAYLIST
	$APPDIR/func_player -playing &
	exit 0
	;;
-remove_from_list)
	if [ "$PLAYLIST" ]; then
		( flock -e 201
			grep -v "$PLAYLIST" $WORKDIR/playlist > $WORKDIR/tmp_remove_from_list
			mv -f $WORKDIR/tmp_remove_from_list $WORKDIR/playlist
		) 201>$WORKDIR/playlist.lockfile 
		$APPDIR/func -statusbar_playlist & #update statusbar
	fi
	;;
-about)
	. $APPDIR/func -reset_gtk
	. $APPDIR/gui_about
	$GTKDIALOG -p pmusic_about
	;;
-undo)
	$APPDIR/func_store_playlist
	( flock -e 201
		echo > $WORKDIR/last_added_playlist
		PLAYLIST_NAME=($(<"$WORKDIR/PLAYLIST_NAME"))
		[ ! "$PLAYLIST_NAME" ] && PLAYLIST_NAME="`ls "$STORAGE_DIR/storage_playlist/" | tail -n 1`"
		[ -s $WORKDIR/playlist ] && PLAYLIST_NAME="`ls "$STORAGE_DIR/storage_playlist/" | grep --before-context=1 -x "$PLAYLIST_NAME" | head -n 1`"
		cp "$STORAGE_DIR/storage_playlist/$PLAYLIST_NAME" $WORKDIR/playlist
		echo "$PLAYLIST_NAME" > $WORKDIR/PLAYLIST_NAME
	) 201>$WORKDIR/playlist.lockfile 
	$APPDIR/func -statusbar_playlist & #update statusbar
	;;
-redo)
	( flock -e 201
		echo > $WORKDIR/last_added_playlist
		PLAYLIST_NAME=($(<"$WORKDIR/PLAYLIST_NAME"))
		TMP="`ls "$STORAGE_DIR/storage_playlist/" | grep --after-context=1 -x "$PLAYLIST_NAME" | tail -n 1`"
		cp "$STORAGE_DIR/storage_playlist/$TMP" $WORKDIR/playlist
		echo "$TMP" > $WORKDIR/PLAYLIST_NAME
		$APPDIR/func -statusbar_playlist & #update statusbar
	) 201>$WORKDIR/playlist.lockfile 
	;;
-edit_tags)
	. $APPDIR/func_trackinfo "$FILE"
	;;
-time_format)
	if [ -f $WORKDIR/ffmpeg_TIME_FORMAT ]; then
		rm $WORKDIR/ffmpeg_TIME_FORMAT
	else
		echo remain > $WORKDIR/ffmpeg_TIME_FORMAT
	fi
	;;
-burn)
	cut -d '|' -f 4 $WORKDIR/playlist | grep -vF "('\|cdda:\|://\|')" > $WORKDIR/tmp #do not include CD tracks and streams
	export BROWSER_DIR=""
#	. $APPDIR/func -reset_gtk
	pburn -i $WORKDIR/tmp -m audio
	;;
-show_location)
	FILE="$2"
	[ ! "$FILE" ] && exit
	SOURCE="`dirname "$FILE"`"
	if type rox > /dev/null 2>&1; then
		rox -d "$SOURCE" &
	else
		echo true > $WORKDIR/UPDATE_SOURCELIST
		. $0 -browse
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;
-quit)
	echo > $WORKDIR/last_added_playlist #this is what shows up in the save-dialog
	STDERR=$WORKDIR/stderr #this is defined at startup, but -quit might be called from a externl signal (as -s quit)
	#first quit guis
	for I in `ps -eo pid,command | grep -Fi pmusic | grep -F gtkdialog | grep -vF radiohits_grabber | awk .'{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done #do not kill radiohits grabber 
	#stop audio
	pmusic -s stop
	rm -f $WORKDIR/gui_is_running #ensure to flag 'no gui'
	#remove play-icon in playlist
#	( flock -e 201
		sed -i "s/gtk-media-play//" $WORKDIR/playlist
#	) 201>$WORKDIR/playlist.lockfile 
	#deactivate equalizer
	mv -f $HOME/.asoundrc $HOME/.asoundrc.bak 2> $STDERR
	#remove temporary cd-audio files
	rm $WORKDIR/*.wav 2> $STDERR
	rm $WORKDIR/*.inf 2> $STDERR
	#remove temporary files, some could be big
	rm $WORKDIR/tmp* 2> $STDERR
	rm $WORKDIR/trackinfo[0-9]* 2> $STDERR #keep the refreshing trackinfo files
	rm $WORKDIR/DONT_SAVE_FRONTEND 2> $STDERR #this is set true by -j switch
	echo -n > $WORKDIR/statusbar
	#kill the rest - in case something is still running
	TMP="`ps -eo pid,command`"
	for I in `echo "$TMP" | grep -i pmusic | grep -i plugins | awk '{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done
	for I in `echo "$TMP" | grep -i pmusic | grep index | awk '{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done
	for I in `echo "$TMP" | grep aplay | awk '{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done
	for I in `echo "$TMP" | grep pmusic | grep playing | awk '{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done
	for I in `echo "$TMP" | grep pmusic | grep gtkdialog | grep -vF radiohits | awk '{print $1} 2> $STDERR'`; do kill -9 $I 2> $STDERR; done
	for I in `echo "$TMP" | grep pmusic | grep -vF radiohits | awk '{print $1}' 2> $STDERR`; do kill -9 $I 2> $STDERR; done
	killall cdda2wav 2> $STDERR
	#reset info about search filters. Next run will use settings from preferences
	rm $WORKDIR/SEARCH_*
	exit 0
	;;
-rename)
	FILE="$2"
	FILENAME="`basename "$FILE" | sed -e 's/\.[^\.]*$//'`"
	[ ! -d "$FILE" ] && EXTENSION=".`basename "$FILE" | sed -e "s/^.*\.//g"`"
	DIR="`dirname "$FILE"`"
	FRAME="$(gettext 'Rename source file')"; IMG="convert"; TXT1="$FILENAME"; DEFAULT="$FILENAME"
	. $APPDIR/box_input
	if [ $EXIT = "ok" ]; then
		#if no name (use of " in name clears variable)
		if [ ! "$INPUT" ] || [ "`grep -E '\||\\|\"'`" ]; then
			TXT1="$(gettext 'Filename is empty!
Be aware that use of some special chars (like \"|) in filename clears value.')"
			. $APPDIR/box_ok
			exit
		fi
		INPUT="`sed 's|"|\\\\"|g' <<< "$INPUT"`"
		#check if already exist
		if [ -f "$DIR"/"$INPUT"."$EXTENSION" ]; then
			TXT1="$DIR"/"$INPUT"."$EXTENSION $(gettext 'already exist')"
			. $APPDIR/box_ok #error
			exit
		fi
		#---
		echo > $WORKDIR/error
		mv "$DIR"/"$FILENAME""$EXTENSION" "$DIR"/"$INPUT""$EXTENSION" 2> $WORKDIR/error

		TXT1=($(<"$WORKDIR/error"))
		if [ -n "$TXT1" ]; then
			. $APPDIR/box_ok #error
		else #update playlist and index
#			NAME="`grep -Fm 1 " $FILE" $WORKDIR/playlist | cut -d'|' -f3`"
			#running sed directly gives problems with special chars
			echo '( flock -e 200' > $WORKDIR/exec3
			echo "sed -i \"s%$DIR/$FILENAME$EXTENSION|$FILENAME$EXTENSION%$DIR/$INPUT$EXTENSION|$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_mymusic\"" >> $WORKDIR/exec3 #in case no metatags is defined in db
			echo "sed -i \"s%$DIR/$FILENAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_mymusic\"" >> $WORKDIR/exec3
			echo ') 200> $WORKDIR/mymusic_db.lockfile' >> $WORKDIR/exec3
			echo "sed -i \"s%$DIR/$FILENAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_recent\"" >> $WORKDIR/exec3
			echo '( flock -e 201' >> $WORKDIR/exec3
			echo "sed -i \"s%$FILENAME$EXTENSION%$INPUT$EXTENSION%g\" $WORKDIR/playlist $WORKDIR/PLAYLIST $WORKDIR/PLAYLIST_ALL" >> $WORKDIR/exec3
			echo ') 201> $WORKDIR/playlist.lockfile' >> $WORKDIR/exec3
			echo "sed -i \"s%$FILENAME$EXTENSION|%$INPUT$EXTENSION|%g\" $WORKDIR/sourcelist" >> $WORKDIR/exec3 #column 2 - name
			echo "sed -i \"s%$DIR/$FILENAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" $WORKDIR/favorites" >> $WORKDIR/exec3
			sed -i 's/\&/\\\&/g' $WORKDIR/exec3
			chmod 777 $WORKDIR/exec3
			$WORKDIR/exec3
			echo true > $WORKDIR/UPDATE_SOURCELIST
			echo true > $WORKDIR/UPDATE_GUI
		fi
	fi
	;;
-copy)
	FILE="$2"
	FRAME="$(gettext 'Copy source file')"; IMG="copy"; TXT1="$FILE"; DEFAULT="$HOME"
	. $APPDIR/box_input
	if [ $EXIT = "ok" ]; then
		while read I; do
			FILENAME="$(basename "$I")"
			echo > $WORKDIR/error
			cp "$I" "$INPUT/$FILENAME" 2> $WORKDIR/error
			TXT1=($(<"$WORKDIR/error"))
			[ -n "$TXT1" ] && . $APPDIR/box_ok #error
		done <<< "$FILE"
	fi
	;;
-delete)
	DEL="$2"
	FRAME="$(gettext 'Delete source file')"; IMG="clear"; TXT1="$DEL"
	. $APPDIR/box_yesno
	if [ $EXIT = "yes" ]; then
		AUDIO_FORMATS2="`echo "$AUDIO_FORMATS" | sed 's/\\$/\\\|/g'`" #example: |/path/file.mp3|
		while read I; do
			rm "$I"
			. $APPDIR/func -remove_from_list
			#clean up index
			grep -vF "$I" "$STORAGE_DIR/index_recent" > $WORKDIR/tmp
			mv $WORKDIR/tmp "$STORAGE_DIR/index_recent"
			( flock -e 200
				grep -vF "$I" "$STORAGE_DIR/index_mymusic" > $WORKDIR/tmp
				mv $WORKDIR/tmp "$STORAGE_DIR/index_mymusic"
			) 200>$WORKDIR/mymusic_db.lockfile 
			grep -vF "$I" "$STORAGE_DIR/favorites" > $WORKDIR/tmp
			mv $WORKDIR/tmp "$STORAGE_DIR/favorites"
			#delete expanded tracks in sourcelist
			if [ "`grep -iE "\.pmu$|\.m3u$|\.pls$" <<< "$I"`" ] && [ "`grep -FA1 "${I}|" $WORKDIR/sourcelist | grep -iE "$AUDIO_FORMATS2"`" ]; then #expanded
				grep -B 1000 ":${I}|" "$WORKDIR/sourcelist" > $WORKDIR/tmp
				grep -A 1000 ":${I}|" "$WORKDIR/sourcelist" | grep -FA1000 -m1 'pmusic_expand_end' | tac | head -n -1 | tac >> $WORKDIR/tmp
				mv $WORKDIR/tmp "$WORKDIR/sourcelist"
			fi
			#---
			grep -v ":${I}|" $WORKDIR/sourcelist | grep -v "^${I}|" > $WORKDIR/tmp #here should probably grep -E been used, but I couldn't make it vork for tracks containing ()
			mv $WORKDIR/tmp $WORKDIR/sourcelist
		done <<< "$DEL"
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;
-set_SAVEFILE)
	echo "$CHOOSER" > $WORKDIR/SAVEFILE
	;;
-save_formats)
	[ ! "$(grep -E "\.pmu|\.m3u|\.pls|\.txt" <<< "${2}")" ] && exit
	if [ $(grep -F '.pmu' <<< "${2}") ]; then
		echo -e "pmu - pMusic $(gettext 'native format')\nm3u - $(gettext 'Supported by most players')\npls - $(gettext 'Shoutcast playlist')\ntxt - $(gettext 'Plain track list')" > $WORKDIR/save_formats
	elif [ $(grep -F '.m3u' <<< "${2}") ]; then
		echo -e "m3u - $(gettext 'Supported by most players')\npmu - pMusic $(gettext 'native format')\npls - $(gettext 'Shoutcast playlist')\ntxt - $(gettext 'Plain track list')" > $WORKDIR/save_formats
	elif [ $(grep -F '.pls' <<< "${2}") ]; then
		echo -e "pls - $(gettext 'Shoutcast playlist')\npmu - pMusic $(gettext 'native format')\nm3u - $(gettext 'Supported by most players')\ntxt - $(gettext 'Plain track list')" > $WORKDIR/save_formats
	elif [ $(grep -F '.txt' <<< "${2}") ]; then
		echo -e "txt - $(gettext 'Plain track list')\npmu - pMusic $(gettext 'native format')\nm3u - $(gettext 'Supported by most players')\npls - $(gettext 'Shoutcast playlist')" > $WORKDIR/save_formats
	fi
	;;
-save)
	. $APPDIR/func -reset_gtk
	TMP="$(<$WORKDIR/last_added_playlist)"
	DIR="`dirname "$TMP"`"
	[ ! -s $WORKDIR/last_added_playlist ] && echo "$HOME/pMusic_playlist.pmu" > $WORKDIR/last_added_playlist
	$APPDIR/func -save_formats "$(<$WORKDIR/last_added_playlist)" &
	export pmusic_save='
	<window title="pMusic - '$(gettext 'Save playlist')'" icon-name="pmusic">
	 <vbox>
	  <timer visible="false">
	   <action>refresh:SAVE_FORMAT</action>
	   <action condition="command_is_true([[ $(grep -F m3u <<< ${SAVE_FORMAT}) ]] && echo true)">enable:SAVE_PATH</action>
	   <action condition="command_is_true([[ $(grep -F txt <<< ${SAVE_FORMAT}) ]] && echo true)">enable:SAVE_PATH</action>
	   <action condition="command_is_true([[ $(grep -F pmu <<< ${SAVE_FORMAT}) ]] && echo true)">disable:SAVE_PATH</action>
	   <action condition="command_is_true([[ $(grep -F pls <<< ${SAVE_FORMAT}) ]] && echo true)">disable:SAVE_PATH</action>
	  </timer>
	  <frame '$(gettext 'Save playlist')'>
	   <hbox>
	    <text><label>'$(gettext 'File')'</label></text>
	    <entry accept="savefilename" width-request="300" fs-filters="*.pmu|*.m3u|*.pls" fs-folder="'$DIR'" fs-title="pMusic - '$(gettext 'Save playlist')'">
	     <variable>SAVEFILE</variable>
	     <input>cat '$WORKDIR'/last_added_playlist</input>
	     <action>'$APPDIR'/func -save_formats "$SAVEFILE"</action>
	     <action signal="activate">exit:ok</action>
	    </entry>
	    <button>
	     <input file stock="gtk-open"></input>
	     <action type="fileselect">SAVEFILE</action>
	    </button>
	   </hbox>
	   <checkbox tooltip-text="'$(gettext 'm3u format supports to skip path description. It will instead use the same path as the m3u file itself. This is handy when music files are moving to a new location.')'">
	    <label>'$(gettext 'Include path')'</label>
	    <variable>SAVE_PATH</variable>
	    <input file>'$WORKDIR'/SAVE_PATH</input>
	    <action>echo $SAVE_PATH > '$WORKDIR'/SAVE_PATH</action>
	   </checkbox>
	   <hbox>
	    <text><label>'$(gettext 'Filetype')'</label></text>
	    <comboboxtext>
	     <variable>SAVE_FORMAT</variable>
	     <input file>'$WORKDIR'/save_formats</input>
	     <action condition="command_is_true([[ $(grep -F pmu <<< ${SAVE_FORMAT}) ]] && echo true)">echo "$SAVEFILE" | sed "s/\.[^\.]*$/.pmu/" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ $(grep -F m3u <<< ${SAVE_FORMAT}) ]] && echo true)">echo "$SAVEFILE" | sed "s/\.[^\.]*$/.m3u/" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ $(grep -F pls <<< ${SAVE_FORMAT}) ]] && echo true)">echo "$SAVEFILE" | sed "s/\.[^\.]*$/.pls/" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ $(grep -F txt <<< ${SAVE_FORMAT}) ]] && echo true)">echo "$SAVEFILE" | sed "s/\.[^\.]*$/.txt/" > '$WORKDIR'/last_added_playlist</action>
	     <action>refresh:SAVEFILE</action>
	    </comboboxtext>
	   </hbox>
	  </frame>
	  <hbox>
	   <button cancel></button>
	   <button can-default="true" has-default="true">
	    <label>'$(gettext 'Ok')'</label>
	    <input file stock="gtk-ok"></input>
	    <action type="exit">ok</action>
	   </button>
	  </hbox>
	 </vbox>
	 <action signal="show" condition="command_is_true([[ `echo $SAVE_FORMAT | grep -F pmu` ]] && echo true)">disable:SAVE_PATH</action>
	 <action signal="show" condition="command_is_true([[ `echo $SAVE_FORMAT | grep -F pls` ]] && echo true)">disable:SAVE_PATH</action>
	</window>'
#	[ $TOOLTIPS = false ] && pmusic_save="`echo "$pmusic_save" | sed 's%tooltip-text%tooltipXXXtext%g'`" #deactivate tooltips
	I=$IFS; IFS=""
	for STATEMENTS in $($GTKDIALOG -p pmusic_save); do
		eval $STATEMENTS
	done
	IFS=$I
	if [ "$EXIT" = "ok" ]; then
		EXT="`echo "$SAVE_FORMAT" | cut -d' ' -f1`"
		SAVEFILE=`echo "$SAVEFILE" | sed -e "s%\.$EXT%%g"` #remove extension if exist.
		if [ -s "$SAVEFILE".$EXT ]; then #already exist
			IMG=dialog-warning
			FRAME="$(gettext 'Warning')"
			TXT1="<b>$SAVEFILE.$EXT $(gettext 'already exist')</b>"
			TXT2="$(gettext 'Do you want to overwrite existing file?')"
			DEFAULT=yes
			. $APPDIR/box_yesno
			if [ $EXIT = no ]; then 
				echo -n > $WORKDIR/SAVEFILE
				exit
			fi
		fi

		if [ "$SAVEFILE" ]; then
			case $EXT in
				txt*)
					echo -n > "$SAVEFILE".txt
					while read I; do
						ADR="`echo "$I" | cut -d'|' -f4`"
						if [ $SAVE_PATH = false ] && [ ! "`grep -E "^http|^cdda" <<< "$ADR"`" ]; then	
							ADR="`basename "$ADR"`" #remove path of files if choosen in gui
						fi
						echo "$ADR" >> "$SAVEFILE".txt
					done < $WORKDIR/playlist
					;;
				m3u*)
					#add EXT info which will speed up reading of the playlist (skip length detection)
					echo '#EXTM3U' > "$SAVEFILE".m3u
					while read I; do
						MIN="`echo "$I" | cut -d'|' -f2 | awk -F: '{ SUM += $1} END { print SUM*60 }'`"
						SEC="`echo "$I" | cut -d'|' -f2 | awk -F: '{ SUM += $2} END { print SUM }'`"
						LENGTH="`echo "$MIN + $SEC" | bc`"
						ADR="`echo "$I" | cut -d'|' -f4`"
						if [ $SAVE_PATH = false ] && [ ! "`grep -E "^http|^cdda" <<< "$ADR"`" ]; then	
							ADR="`basename "$ADR"`" #remove path of files if choosen in gui
						fi
						NAME="`echo "$I" | cut -d'|' -f3`"
						#---
						echo -e "#EXTINFO:${LENGTH},$NAME\n$ADR" >> "$SAVEFILE".m3u
					done < $WORKDIR/playlist
					;;
				pls*)
					#add EXT info which will speed up reading of the playlist (skip length detection)
					COUNT=1
					echo -n -e "[playlist]\nNumberOfEntries=" > "$SAVEFILE".pls
					grep -c "^" $WORKDIR/playlist >> "$SAVEFILE".pls
					while read I; do
						#File
						echo -n "File${COUNT}=" >> "$SAVEFILE".pls
						cut -d'|' -f4 <<< "$I" >> "$SAVEFILE".pls
						#Title
						echo -n "Title${COUNT}=" >> "$SAVEFILE".pls
						cut -d'|' -f3 <<< "$I" >> "$SAVEFILE".pls
						#Length
						MIN="`echo "$I" | cut -d'|' -f2 | awk -F: '{ SUM += $1} END { print SUM*60 }'`"
						SEC="`echo "$I" | cut -d'|' -f2 | awk -F: '{ SUM += $2} END { print SUM }'`"
						echo -n "Length${COUNT}=" >> "$SAVEFILE".pls
						echo "$MIN + $SEC" | bc >> "$SAVEFILE".pls
						#---
						COUNT=$(($COUNT+1))
					done < $WORKDIR/playlist
					;;
				pmu*)
					cp $WORKDIR/playlist "$SAVEFILE".pmu
					;;
			esac
			#---
			echo "$SAVEFILE".$EXT > $WORKDIR/last_added_playlist
			#update index
			if [ "`grep "$STORAGE_DIR/pmu" <<< "$SAVEFILE"`" ]; then #if saved to pmu storage we suppose it is a edited pmusic-generated album. 
				ARTIST="`basename ${SAVEFILE} | awk -F' - ' '{print $1}'`"
				ALBUM="`basename ${SAVEFILE} | awk -F' - ' '{print $2}'`"
			else
				ARTIST="`basename ${SAVEFILE}`"
				ALBUM=""
			fi
			grep -v "^${SAVEFILE}.$EXT|" "$STORAGE_DIR/index_mymusic" > $WORKDIR/tmp_save
			mv -f $WORKDIR/tmp_save "$STORAGE_DIR/index_mymusic"
			( flock -e 200
				echo "${SAVEFILE}.$EXT|$ARTIST||$ALBUM||||||||||${SAVEFILE}.$EXT|gtk-audio_playlist||||||" >> "$STORAGE_DIR/index_mymusic"
			) 200>$WORKDIR/mymusic_db.lockfile
		else
			TXT1="<b>$(gettext 'Target file is not defined')</b>"
			. $APPDIR/box_ok
		fi
	fi
	;;
-new)
	echo -n > $WORKDIR/playlist
	echo > $WORKDIR/last_added_playlist
	$APPDIR/func -statusbar_playlist & #update statusbar
	;;



	
##############      Search      ################

-search)
	kill -9 `ps -eo pid,command | grep -F pmusic | grep -F search2 | awk '{print $1}'` 2> $STDERR #kill ongoing search
	case $SEARCH in
		*/*) echo ;;
		*) $APPDIR/func -search2 &;;
	esac
	;;
-search2)
	#this is searching while typing -- only use this for local files (speed issue)
	if [ $SEARCH_MYMUSIC = false ] && [ $SEARCH_RADIO = false ] && [ $SEARCH_WEBMUSIC = false ]; then exit; fi
	[ $UTF8 != false ] && exit #using UTF-8 is too slow to search while typing
	#---
	echo "export LC_ALL=C" > $WORKDIR/tmp_exec
	echo -n "cat " >> $WORKDIR/tmp_exec
	[ $SEARCH_MYMUSIC = true ] && echo -n "\"$STORAGE_DIR/index_mymusic\" " >> $WORKDIR/tmp_exec
	[ $SEARCH_RADIO = true ] && echo -n "\"$STORAGE_DIR/index_radio\" " >> $WORKDIR/tmp_exec
	[ $SEARCH_WEBMUSIC = true ] && echo -n "\"$STORAGE_DIR/index_webmusic*\" " >> $WORKDIR/tmp_exec
	IFS=" "
	for I in $SEARCH; do echo -n "| grep -iF '$I' " >> $WORKDIR/tmp_exec; done
	echo -n " > $WORKDIR/tmp_sourcelist" >> $WORKDIR/tmp_exec
	chmod 700 $WORKDIR/tmp_exec
	$WORKDIR/tmp_exec 2> $STDERR #execute
	echo "$SEARCH" > $WORKDIR/filebrowser_dir #remember searchtext for next keystroke
	#refresh browser field only if small amount of hits
	if [ `grep -c '^' $WORKDIR/tmp_sourcelist` -lt 500 ]; then
		mv $WORKDIR/tmp_sourcelist $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;
-search_refresh) #click enter in search-field.
	case $SEARCH in
		'')
			echo > $WORKDIR/sourcelist
			exit
			;;
		http://*|https://*)
			SOURCE="$SEARCH"
			. $APPDIR/func_add -add
			echo true > $WORKDIR/UPDATE_GUI
			;;
		/*) #if file --> add to playlist
			if [ -f "$SEARCH" ]; then
				SOURCE="$SEARCH"
				. $APPDIR/func_add -add
				echo true > $WORKDIR/UPDATE_GUI
			else #browse
				SOURCE="$SEARCH"
				. $APPDIR/func -browse "$*"
			fi
			exit
			;;
		*) #search
			#if only one song in list --> add to playlist 
			if [ "`grep  -F "^/" $WORKDIR/sourcelist`" ] && [  | `grep -c "^" $WORKDIR/sourcelist` = 1 ]; then
				SOURCE="`cut -d'|' -f1 $WORKDIR/sourcelist`"
				. $APPDIR/func_add -add
				echo true > $WORKDIR/UPDATE_GUI
			#else, search
			else
				#full search
				kill -9 `ps -eo pid,command | grep pmusic | grep search2 | awk '{print $1}'` #kill ongoing search
				#clicking on an albumart (searched) we send an extra attribute to avoid albumart-update
				if [ "$2" ]; then
					$APPDIR/func -search_sources "$SEARCH" no_albumart
					NO_UPDATE=no_albumart
				else
					$APPDIR/func -search_sources "$SEARCH" no_update
				fi
				mv -f $WORKDIR/search_sources $WORKDIR/sourcelist
				echo "$SEARCH" > $WORKDIR/filebrowser_dir #remember searchtext for next keystroke
			fi
			;;
	esac
#	#if only 1 track found - add it to playlist 
#	[ "`cut -d'|' -f1 $WORKDIR/sourcelist | grep -ciE "$AUDIO_FORMATS"`" = "1" ] && $APPDIR/func_add -add "`grep -F '/' $WORKDIR/sourcelist | cut -d'|' -f1`" &
	#update history
	[ "$NO_UPDATE" != "no_albumart" ] && $APPDIR/func -add_to_history "$SEARCH" & #we don't want to keep info when user click on albumart
	;;
-search_sources) #this is also used to update the content of sourclist (ie. to update tags).
	SEARCH="$2"
	NO_UPDATE="$3" #point result to another target, or udating of sourcelist is done in gui-code to give an imidiate response
	#this seperates searchresults in different groups
	IFS=" "
	echo > $WORKDIR/tmp_exec
	[ $UTF8 = false ] && echo "export LC_ALL=C" >> $WORKDIR/tmp_exec
	echo "echo -n > $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
	#pMusic allows '-' to define what should NOT be in searchresult. We deal with that after the initial search
	SEARCHSTRING="$SEARCH" #for history index...
	NOT_SEARCH="`echo "$SEARCH" | tr ' ' '\n' | grep "^-" | cut -c2- | tr '\n' ' '`"
	SEARCH="`echo "$SEARCHSTRING" | tr ' ' '\n' | grep -v "^-" | tr '\n' ' '`"
	#When in Radio streamer frontend we should only search for radio stations.
	if [ "`grep -F '.Radio' $WORKDIR/xml_pmusic_tmp`" ]; then
		SEARCH_COLLECTIONS=false
		SEARCH_MYMUSIC=false
		SEARCH_ALBUMART=false
		SEARCH_RADIO=true
		SEARCH_WEBMUSIC=false
		SEARCH_FILES=false
	fi


	#pfilesearch
	if [ $SEARCH_FILES = true ] && type pfilesearch > /dev/null 2>&1; then
		#no heading is necessary if user don't use any of the indexes.
		if [ $SEARCH_MYMUSIC = true ] || [ $SEARCH_COLLECTIONS = true ] || [ $SEARCH_RADIO = true ] || [ $SEARCH_WEBMUSIC = true ]; then
			echo "echo -e '\n|__${SEARCHPATH}__' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
		#---
		echo "pfilesearch -bb -f music -c \"${SEARCH// /[AND]}\" -d \"$SEARCHPATH\"" >> $WORKDIR/tmp_exec
		echo 'sort -u --output='$WORKDIR'/tmp3 '$HOME'/.pfilesearch/hits' >> $WORKDIR/tmp_exec
		echo 'paste -d"|" '$WORKDIR'/tmp3 '$WORKDIR'/tmp3 >> '$WORKDIR'/search_sources' >> $WORKDIR/tmp_exec
	fi


	#My music - Local tracks
	#First we search for both tracks and collections (for speed)
	if [ $SEARCH_COLLECTIONS = true ] || [ $SEARCH_MYMUSIC = true ]; then
		echo "find \"$STORAGE_DIR/favorite_lists/\" -type f -printf \"%p|%f||||||||||||%p|gtk-audio_playlist_favorites||||||\n\" > $WORKDIR/tmp_search_fav" >> $WORKDIR/tmp_exec
		echo -n "cat \"$STORAGE_DIR/index_mymusic\" $WORKDIR/tmp_search_fav" >> $WORKDIR/tmp_exec
		for I in $SEARCH; do TMP="`echo "$I" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done #'
		echo " > $WORKDIR/tmp_search" >> $WORKDIR/tmp_exec
		if [ $SEARCH_COLLECTIONS = true ]; then
			#search inside MyMusic index
			if [ -s "$STORAGE_DIR/index_mymusic" ]; then
				echo "echo -e '\n|__  $(gettext 'M Y   L I S T S')  __' > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
				echo "grep -HiE \"\.pmu\||\.pmd\||\.m3u\||\.pls\|\" $WORKDIR/tmp_search | grep -vF \"$STORAGE_DIR/pmu\" > $WORKDIR/tmp_search_sources2" >> $WORKDIR/tmp_exec
				echo "grep -iF '.pls|' $WORKDIR/tmp_search >> $WORKDIR/search_sources2" >> $WORKDIR/tmp_exec
				echo "[ -s $WORKDIR/tmp_search_sources2 ] && cat $WORKDIR/tmp_search_sources $WORKDIR/tmp_search_sources2 >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
				#---
				echo "echo -e '\n|__  $(gettext 'A L B U M S')  __' > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
				echo "grep -HF \"$STORAGE_DIR/pmu\" $WORKDIR/tmp_search  > $WORKDIR/tmp_search_sources2" >> $WORKDIR/tmp_exec
				echo "[ -s $WORKDIR/tmp_search_sources2 ] && cat $WORKDIR/tmp_search_sources $WORKDIR/tmp_search_sources2 >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
				#---
				echo "sed -i 's%$WORKDIR/tmp_search%pmusicbrowse_expand%g' $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			fi
		fi
		if [ $SEARCH_MYMUSIC = true ]; then
			#index tracks
			echo "echo -e '\npmusic_index|__  $(gettext 'M Y   T R A C K S')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			if [ -s "$STORAGE_DIR/index_mymusic" ]; then
				echo "grep -ivE \"\.pmu\||\.m3u\||\.pls\||\.pmd\|\" $WORKDIR/tmp_search > $WORKDIR/tmp_search_tracks" >> $WORKDIR/tmp_exec
				#update icons and visible rating coloumn in db
				echo "$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_search_tracks >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			fi
		fi
	fi

	#album art
	if [ $SEARCH_ALBUMART = true ] && [ "$NO_UPDATE" != "no_albumart" ]; then
		TMP="$(cut -d' ' -f1 <<< "${SEARCH}")"
		echo "find \"$STORAGE_DIR/albumart/\" -iname \"*${TMP}*\" -printf \"%p\n\" > $WORKDIR/tmp_search_albumart1" >> $WORKDIR/tmp_exec
		echo -n "cat $WORKDIR/tmp_search_albumart1" >> $WORKDIR/tmp_exec
		for I in $SEARCH; do TMP="`echo "$I" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done
		echo " > $WORKDIR/tmp_search_albumart" >> $WORKDIR/tmp_exec
#		echo " | head -n 10 > $WORKDIR/tmp_search_albumart" >> $WORKDIR/tmp_exec
	fi

	#radio
	if [ $SEARCH_RADIO = true ]; then
		echo "echo -e '\npmusic_radio|__  $(gettext 'R A D I O')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		if [ -s "$STORAGE_DIR/index_radio" ]; then
			echo -n "awk -F'\\n' '{print \$1 \"|||||||||||gtk-audio_url\"}' \"$STORAGE_DIR/index_radio\"" >> $WORKDIR/tmp_exec
			for I in $SEARCH; do TMP="`echo "$I" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done
			echo " >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		else #message
			echo "echo -e \"pmusic_radio|$(gettext 'Missing index')|||||||||||||gtk-info\npmusic_radio|$(gettext 'Doubleclick here to setup')\" >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
	fi


	#webmusic
	if [ $SEARCH_WEBMUSIC = true ]; then
		echo "echo -e '\npmusic_webmusic_manager|__  $(gettext 'W E B   M U S I C')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		if [ -s "$STORAGE_DIR/index_webmusic_youtube" ]; then
			echo -n "cat \"$STORAGE_DIR/index_webmusic_youtube\"" >> $WORKDIR/tmp_exec
			for I in $SEARCH; do TMP="`echo "$I" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done
			echo " >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
		if [ -s "$STORAGE_DIR/index_webmusic_jamendo" ]; then
			echo -n "cut -c 2- \"$STORAGE_DIR/index_webmusic_jamendo\"" >> $WORKDIR/tmp_exec
			for I in $SEARCH; do TMP="`echo "${I}" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done
			#jamendo index is shrinked with a cut down url. We need to expand URL
			echo " | awk -F \"|\" '{print \"http://api.jamendo.com/get2/stream/track/redirect/?streamencoding=mp31&id=\"\$1\" | \"\$2\" | \"\$3\" | \"\$4\" | \"\$5\" | \"\$6\" | \"\$7\" | \"\$8\" | \"\$9\" | \"\$10\" | \"\$11\" | \"\$12 }' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
#			echo " | sed 's%+%http://api.jamendo.com/get2/stream/track/redirect/?streamencoding=mp31\&id=%' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
		#if no indexes is present - search jamendo.com
		if [ ! -s "$STORAGE_DIR/index_webmusic_youtube" ] && [ ! -s "$STORAGE_DIR/index_webmusic_jamendo" ]; then
		
			echo "echo -e \"|$(gettext 'Missing index limits search')\n|    - $(gettext 'Much SLOWER')\n|    - $(gettext 'No multitag search')\n|    - $(gettext 'Max results is 500 pr search')\n|$(gettext 'See Setup in Music-sources menu')\" >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			echo "wget -t 1 --connect-timeout=1 -O - \"http://api.jamendo.com/get2/id+artist_name+name+album_name+numalbum+dates+genre+duration/track/plain/track_album+album_artist/?searchquery=${SEARCH// /+}&order=searchweight_desc&n=500\" | tr '\t' '|' | sed -e 's/http:/  96      /g' -e 's/Array//g' -e 's/^/http:\/\/api.jamendo.com\/get2\/stream\/track\/redirect\/?streamencoding=mp31\&id=/g' > $WORKDIR/tmp_wget" >> $WORKDIR/tmp_exec
			echo "if grep -F http: $WORKDIR/tmp_wget; then cat $WORKDIR/tmp_wget >> $WORKDIR/search_sources; echo >> $WORKDIR/search_sources; fi" >> $WORKDIR/tmp_exec
		fi
	fi
	#remove first empty lines
	echo "head -n 1001 $WORKDIR/search_sources | tac | head -n-1 | tac > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
	#execute
	chmod 700 $WORKDIR/tmp_exec
	$WORKDIR/tmp_exec
	#pMusic allows '-' to define what should NOT be in searchresult
	if [ "$NOT_SEARCH" ]; then
		cp -f $WORKDIR/tmp_search_sources $WORKDIR/tmp
		for I in $NOT_SEARCH; do
			grep -viF "$I" $WORKDIR/tmp > $WORKDIR/tmp2
			mv -f $WORKDIR/tmp2 $WORKDIR/tmp
		done
		mv -f $WORKDIR/tmp $WORKDIR/tmp_search_sources
	fi
	#show only the first 1000 hits
	NR=1000 #max_view
	if [ `grep -c ^ $WORKDIR/tmp_search_sources` -ge $NR ]; then
		echo -e "|$(gettext 'More than') $NR $(gettext 'hits')|||||||||||||gtk-info\n|$(gettext 'Please narrow search')\n|___________________________\n" > $WORKDIR/search_sources
	else
		mv -f $WORKDIR/tmp_search_sources $WORKDIR/search_sources
	fi
	#here ends the ordinay search.
	#update pics for albumart search
	if [ $SEARCH_ALBUMART = true ] && [ "$NO_UPDATE" != "no_albumart" ]; then
		$APPDIR/func -search_albumart_update
	fi
	#now this function is used only to update content in sourcelist. This is possible because search history is stored in index_history
	#see ie. id3io -write
	if [ "$NO_UPDATE" != "no_update" ]; then
		mv -f $WORKDIR/search_sources $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	#---
	;;
-search_albumart_update)
	IFS=$'\n'
	COUNT=0
	NR=1
	TOTAL="`cat $WORKDIR/tmp_search_albumart | wc -l`"
	#are we navigating in album-arts
	if [ "$2" = "prev" ]; then
		TMP=$(<$WORKDIR/albumart_search_START_NR)
		if [ $(($TMP-1)) -gt $ALBUMART_SEARCH_NR ]; then
			START_NR=$(($TMP-$ALBUMART_SEARCH_NR-1))
			cp $APPDIR/themes/$THEME/icon_go_left.svg $WORKDIR/albumart_search_prev.svg
			echo $START_NR > $WORKDIR/albumart_search_START_NR
		else
			START_NR=0
			cp $APPDIR/themes/$THEME/blank.svg $WORKDIR/albumart_search_prev.svg
			echo 0 > $WORKDIR/albumart_search_START_NR
		fi
		cp $APPDIR/themes/$THEME/icon_go_right.svg $WORKDIR/albumart_search_next.svg
	elif [ "$2" = "next" ]; then
		TMP=$(<$WORKDIR/albumart_search_START_NR)
		START_NR=$(($TMP+$ALBUMART_SEARCH_NR+1))
		[ $START_NR -gt $TOTAL ] && exit
		echo $START_NR > $WORKDIR/albumart_search_START_NR
		cp $APPDIR/themes/$THEME/icon_go_left.svg $WORKDIR/albumart_search_prev.svg
		cp $APPDIR/themes/$THEME/icon_go_right.svg $WORKDIR/albumart_search_next.svg
	else
		START_NR=0
		echo 0 > $WORKDIR/albumart_search_START_NR
		cp $APPDIR/themes/$THEME/blank.svg $WORKDIR/albumart_search_prev.svg
		[ $ALBUMART_SEARCH_NR -ge $TOTAL ] && cp $APPDIR/themes/$THEME/blank.svg $WORKDIR/albumart_search_next.svg || cp $APPDIR/themes/$THEME/icon_go_right.svg $WORKDIR/albumart_search_next.svg
	fi
	#---
	for I in $(seq 1 $ALBUMART_SEARCH_NR); do rm $WORKDIR/albumart_search$I.jpg; done
	while read I in; do
		#define arrow-buttons
		COUNT=$(($COUNT+1))
		[ $COUNT -lt $START_NR ] && continue
		if [ $COUNT = $TOTAL ]; then cp $APPDIR/themes/$THEME/blank.svg $WORKDIR/albumart_search_next.svg; fi
		#in case item is a guess, let's check if pic exist
		if [ ! -f "$I" ]; then
			TMP="$(basename "$I")"
			I="`find "$STORAGE_DIR"/albumart -iname "$TMP" -printf "%p\n" | head -n 1`" #accept chars/capitals
			[ ! -f "$I" ] && continue
		fi
		#---
		ln -sf "$I" $WORKDIR/albumart_search$NR.jpg
		NR=$(($NR+1))
		[ $NR -gt $ALBUMART_SEARCH_NR ] && break
	done < $WORKDIR/tmp_search_albumart
	IFS=" "
	;;
-pfilesearch)
	#check if pfilesearch is installed
	if ! type pfilesearch > /dev/null 2>&1; then
		TXT1="<b>Pfilesearch</b> $(gettext 'is not installed')"
		. $APPDIR/box_ok
		exit
	fi
	#---
	pfilesearch -bb -f music -d "$SEARCHPATH"
	sort -u --output=$WORKDIR/tmp $HOME/.pfilesearch/hits
	paste -d'|' $WORKDIR/tmp $WORKDIR/tmp > $WORKDIR/sourcelist
	echo true > $WORKDIR/UPDATE_SOURCELIST
	;;


##############       Misc        #################

#-index_songs)
#	if [ ! -s "$STORAGE_DIR/index_mymusic" ]; then
#		echo -e "|$(gettext 'Missing index. See menu:')\n|-> $(gettext 'Music sources')\n|    -> $(gettext 'My Music')\n|        -> $(gettext 'Setup')" > $WORKDIR/sourcelist
#	else
#		NR=1000
#		echo -n > $WORKDIR/sourcelist
#		TMP="`echo "$AUDIO_FORMATS" | sed 's/$/|/g'`"
#		LC_ALL=C sort -ust'|' -k 2,2 "$STORAGE_DIR/index_mymusic" | grep -iE -m $NR "$TMP" > $WORKDIR/tmp_sourcelist
#		[ `cat $WORKDIR/tmp_sourcelist | wc -l` -ge $NR ] && echo -e "|$(gettext 'You have a lot of music')|||||||||||||gtk-info\n|$(gettext 'Please search instead')\n\n|$(gettext 'Maximum view'): $NR\n|___________________________\n\n" >> $WORKDIR/sourcelist
#		$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_sourcelist >> $WORKDIR/sourcelist
#	fi
#	$APPDIR/func -add_to_history "pMusic: $(gettext 'My Tracks')" & #update history
#	;;
#-index_playlists)
#	if [ ! -s "$STORAGE_DIR/index_mymusic" ]; then
#		echo -e "|$(gettext 'Missing index. See menu:')\n|-> $(gettext 'Music sources')\n|    -> $(gettext 'My Music')\n|        -> $(gettext 'Setup')" > $WORKDIR/sourcelist
#	else
#		NR=1000
#		echo -n > $WORKDIR/sourcelist
#		LC_ALL=C sort -ust'|' -k 2,2 "$STORAGE_DIR/index_mymusic" | grep -iE -m $NR "\.pmu\||\.m3u\||\.pls\|" > $WORKDIR/tmp_sourcelist
#		[ `cat $WORKDIR/tmp_sourcelist | wc -l` -ge $NR ] && echo -e "|$(gettext 'You have a lot of music')|||||||||||||gtk-info\n|$(gettext 'Please search instead')\n\n|$(gettext 'Maximum view'): $NR\n|___________________________\n\n" >> $WORKDIR/sourcelist
#		cat $WORKDIR/tmp_sourcelist >> $WORKDIR/sourcelist
#	fi
#	$APPDIR/func -add_to_history "pMusic: $(gettext 'My Collections')" & #update history
#	;;
-index_recent)
	NR=1000
	#reverse list to get last item on top.
	echo -n > $WORKDIR/tmp
	while read I; do
		echo "$NR|$I" >> $WORKDIR/tmp
		NR=$(($NR+1))
	done < "$STORAGE_DIR/index_recent"
	sort -r $WORKDIR/tmp | cut -d '|' -f 2- > $WORKDIR/sourcelist
	tail -n 1000 $WORKDIR/tmp | cut -d '|' -f 2- > "$STORAGE_DIR/index_recent" #keep only the last 1000
#	#album art
#	if [ $SEARCH_ALBUMART = true ]; then
#		head -n 30 $WORKDIR/sourcelist | awk -F'|' -v VAR1="$STORAGE_DIR" '{print VAR1 "/albumart/" $2 " - " $4 ".jpg"}' | awk '!a[$0]++' > $WORKDIR/tmp_search_albumart
#		$APPDIR/func -search_albumart_update
#	fi
	#---
	$APPDIR/func -add_to_history "pMusic: $(gettext 'Recent played')" & #update history
	;;
-index_history)
	NR=100
	#reverse list to get last item on top.
	echo -n > $WORKDIR/tmp
	while read I; do
		echo "$NR|$I" >> $WORKDIR/tmp
		NR=$(($NR+1))
	done < "$STORAGE_DIR/index_history"
	sort -r $WORKDIR/tmp | cut -d '|' -f 3- > $WORKDIR/sourcelist
	tail -n 100 $WORKDIR/tmp | cut -d '|' -f 2- > "$STORAGE_DIR/index_history" #keep only the last 100
 	#---
	$APPDIR/func -add_to_history "pMusic: $(gettext 'History')" & #update history
	;;
-info_IWantMusic)
	HEADING="$(gettext 'I want music')"
	IMG='none'
	FRAME="$(gettext 'info')"
	TXT1="$(gettext 'In addition to be an audioplayer and music manager, pMusic is also a tool to build up your own local music collection. This includes audio, lyrics, album art and album playlists.

In the Music-Source menu, you will find different ways to access music. One of the sources is the RadioHits Grabber that records a radio station and splits the music tracks into different files with correct naming. More info there...

When it comes to lyrics, album art and album playlists, these are downloaded while playing a track. pMusic can store them to a given directory. This is set in the preferences.

A local storage is recommended for snapiness. Lyrics and album art will work ok without a local storage, but not Album playlists. pMusic will search through your music collection and put together songs belonging to each album. These album playlists (and their tracks) will be available when searching, and in the track info window.

pMusic also supports jamendo.com which is a website for free music. It contains a huge amount of music; freely available for you.')"
	. $APPDIR/box_ok &
	;;
esac
